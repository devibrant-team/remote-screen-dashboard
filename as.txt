// src/Screens/Schedule/Calender/Calender.tsx
import React, { useEffect, useMemo, useRef, useState } from "react";
import FullCalendar from "@fullcalendar/react";
import dayGridPlugin from "@fullcalendar/daygrid";
import timeGridPlugin from "@fullcalendar/timegrid";
import interactionPlugin, {
  type DateClickArg,
  type EventResizeDoneArg,
} from "@fullcalendar/interaction";
import AssignSchedulebar from "../AssignSchedulebar";
import type {
  DateSelectArg,
  EventClickArg,
  EventContentArg,
  EventDropArg,
  DatesSetArg,
} from "@fullcalendar/core";
import { useDispatch, useSelector } from "react-redux";
import type { RootState } from "../../../../store";
import {
  setSelectedBlock,
  clearSelectedBlock,
  type Block,
} from "../../../Redux/Block/BlockSlice";
import { removeScheduleItemBlock } from "../../../Redux/ScheduleItem/ScheduleItemSlice";
import { useDeleteReservedBlock } from "../../../Redux/Block/DeleteBlock";
import { setCalendarView } from "@/Redux/Calendar/calendarViewSlice";
import { useScheduleItemBlocksByView } from "@/Redux/ScheduleItem/useScheduleItemBlocksByView";
import type { ScheduleBlock } from "@/Redux/ScheduleItem/GetScheduleItemBlocks";

declare global {
  interface Window {
    __draggingPlaylist?: boolean;
  }
}
const isDraggingPlaylist = () => Boolean(window.__draggingPlaylist);

/* -------------------------------- types ---------------------------------- */
type CalenderProps = {
  initialView?: "timeGridWeek" | "timeGridDay" | "dayGridMonth";
  events?: Array<{
    id?: string;
    title: string;
    start: string | Date;
    end?: string | Date;
    allDay?: boolean;
    extendedProps?: { borderClass?: string };
  }>;
  onDateClick?: (arg: DateClickArg) => void;
  onEventClick?: (arg: EventClickArg) => void;
};

type LocalEvt = {
  id: string;
  title: string;
  start: Date | string;
  end?: Date | string;
  allDay?: boolean;
  extendedProps?: { borderClass?: string; isLocal?: boolean; [k: string]: any };
};

/* -------------------------------- helpers -------------------------------- */
const DEFAULT_BORDER = "border-red-600";

const minutesToDur = (m: number) => {
  const mins = Math.max(1, Math.min(360, Math.floor(m || 0)));
  const h = Math.floor(mins / 60);
  const mm = mins % 60;
  const pad = (n: number) => (n < 10 ? `0${n}` : `${n}`);
  return `${pad(h)}:${pad(mm)}:00`;
};

const toTs = (v?: Date | string | null) =>
  !v ? Number.NaN : typeof v === "string" ? new Date(v).getTime() : v.getTime();

const toNum = (v: any): number | undefined => {
  const n = typeof v === "number" ? v : Number(v);
  return Number.isFinite(n) ? n : undefined;
};

function colorize(input: LocalEvt[]): LocalEvt[] {
  const arr = [...input].sort((a, b) => {
    const as = toTs(a.start),
      bs = toTs(b.start);
    if (as !== bs) return as - bs;
    return (toTs(a.end) || as) - (toTs(b.end) || bs);
  });
  return arr.map((e) => ({
    ...e,
    extendedProps: {
      ...(e.extendedProps ?? {}),
      borderClass: e.extendedProps?.borderClass ?? DEFAULT_BORDER,
      isLocal: e.extendedProps?.isLocal ?? false,
    },
  }));
}

const toBg = (cls?: string) =>
  cls && cls.startsWith("border-")
    ? cls.replace("border-", "bg-")
    : cls ?? "bg-red-600";

let uid = 1;
const newId = () => `e${uid++}`;

const pad = (n: number) => (n < 10 ? `0${n}` : `${n}`);
const fmtDay = (d: Date) =>
  `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())}`;
const fmtTime = (d: Date) =>
  `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;

/* -------------------------------- component ------------------------------- */
const CalenderForScheduleItem: React.FC<CalenderProps> = ({
  initialView = "timeGridWeek",
  events,
  onDateClick,
  onEventClick,
}) => {
  const calendarRef = useRef<FullCalendar | null>(null);
  const [assignOpen, setAssignOpen] = useState(false);
  const [slotStepMin, setSlotStepMin] = useState<number>(30);
  const dispatch = useDispatch();

  // üî• blocks limited to current calendar view (React Query)
  const {
    data: blocksData,
    isLoading: blocksLoading,
    isFetching: blocksFetching,
  } = useScheduleItemBlocksByView();

  const ScheduleItemblocks: ScheduleBlock[] = blocksData ?? [];

  const selectedScreenStr = useSelector(
    (s: RootState) => s.ScheduleItem.selectedscreenId
  );
  const selectedGroupStr = useSelector(
    (s: RootState) => s.ScheduleItem.selectedgroupId
  );

  const selectedScreenId =
    selectedScreenStr != null ? Number(selectedScreenStr) : null;
  const selectedGroupId =
    selectedGroupStr != null ? Number(selectedGroupStr) : null;

  const { start, end, viewKey } = useSelector((s: RootState) => s.calendarView);
  console.log("start at", start, "end at ", end, "KEY", viewKey);

  const [evts, setEvts] = useState<LocalEvt[]>(
    colorize((events ?? []).map((e, i) => ({ ...e, id: e.id ?? `seed-${i}` })))
  );

  function toDateTime(day?: string, time?: string): Date | undefined {
    if (!day || !time) return undefined;
    const d = new Date(`${day}T${time}`);
    return isNaN(d.getTime()) ? undefined : d;
  }

  const backendEvents: LocalEvt[] = useMemo(() => {
    if (!Array.isArray(ScheduleItemblocks)) return [];
    return ScheduleItemblocks.map((b: ScheduleBlock) => {
      const start =
        toDateTime(b.start_day as any, b.start_time as any) ?? new Date();
      const fallbackEnd = new Date(start.getTime() + 30 * 60 * 1000);
      const end =
        toDateTime(b.end_day as any, b.end_time as any) ?? fallbackEnd;

      const title = b.playlistName
        ? String(b.playlistName)
        : `Block #${b.id}`;

      return {
        id: `block-${b.id}`,
        title,
        start,
        end,
        allDay: false,
        extendedProps: { borderClass: DEFAULT_BORDER, isLocal: false },
      };
    });
  }, [ScheduleItemblocks]);

  const filteredBackendEvents: LocalEvt[] = useMemo(() => {
    if (selectedScreenId == null && selectedGroupId == null)
      return backendEvents;

    const matches = (b: ScheduleBlock) => {
      const hasScreen =
        selectedScreenId == null
          ? true
          : (b.screens ?? []).some((s: any) => {
              const id = typeof s?.id === "number" ? s.id : Number(s?.id);
              return Number.isFinite(id) && id === selectedScreenId;
            });

      const hasGroup =
        selectedGroupId == null
          ? true
          : (b.groups ?? []).some((g: any) => {
              const id = typeof g?.id === "number" ? g.id : Number(g?.id);
              return Number.isFinite(id) && id === selectedGroupId;
            });

      return hasScreen && hasGroup;
    };

    const selectedBlocks = ScheduleItemblocks.filter(matches);

    return selectedBlocks.map((b: ScheduleBlock) => {
      const start =
        toDateTime(b.start_day as any, b.start_time as any) ?? new Date();
      const fallbackEnd = new Date(start.getTime() + 30 * 60 * 1000);
      const end =
        toDateTime(b.end_day as any, b.end_time as any) ?? fallbackEnd;

      const title = b.playlistName
        ? String(b.playlistName)
        : `Block #${b.id}`;

      return {
        id: `block-${b.id}`,
        title,
        start,
        end,
        allDay: false,
        extendedProps: { borderClass: DEFAULT_BORDER, isLocal: false },
      };
    });
  }, [ScheduleItemblocks, backendEvents, selectedScreenId, selectedGroupId]);

  const finalEvents = useMemo(
    () => colorize([...(filteredBackendEvents ?? []), ...(evts ?? [])]),
    [filteredBackendEvents, evts]
  );

  // delete hook and helpers
  const { mutateAsync: deleteBlock } = useDeleteReservedBlock();

  const toServerId = (eventId: string): number | null => {
    if (!eventId) return null;
    if (eventId.startsWith("block-")) {
      const n = Number(eventId.replace("block-", ""));
      return Number.isFinite(n) ? n : null;
    }
    const n = Number(eventId);
    return Number.isFinite(n) ? n : null;
  };

  const handleDeleteEvent = async (eventId: string) => {
    const idNum = toServerId(eventId);
    if (!idNum) return;
    if (!window.confirm("Delete this block?")) return;
    try {
      await deleteBlock(idNum); // DB delete
      dispatch(removeScheduleItemBlock(idNum));
      setEvts((prev) =>
        prev.filter((x) => x.id !== String(idNum) && x.id !== `block-${idNum}`)
      );
      window.dispatchEvent(
        new CustomEvent("schedule/removed", { detail: { id: String(idNum) } })
      );
    } catch (err) {
      console.error("[CalenderForScheduleItem delete] error:", err);
    }
  };

  // Listen for external removals (keep local evts in sync)
  useEffect(() => {
    const onRemoved = (e: Event) => {
      const { id } = (e as CustomEvent<{ id?: string }>).detail ?? {};
      if (!id) return;
      setEvts((prev) =>
        prev.filter((x) => x.id !== id && x.id !== `block-${id}`)
      );
    };
    window.addEventListener("schedule/removed", onRemoved as EventListener);
    return () => {
      window.removeEventListener(
        "schedule/removed",
        onRemoved as EventListener
      );
    };
  }, []);

  const renderEvent = (content: EventContentArg) => {
    const { borderClass, isLocal } =
      (content.event.extendedProps as {
        borderClass?: string;
        isLocal?: boolean;
      }) || {};
    const stripeBg = toBg(borderClass || DEFAULT_BORDER);

    const onRemoveLocal = (e: React.MouseEvent) => {
      e.stopPropagation();
      e.preventDefault();
      const id = content.event.id;
      setEvts((prev) => prev.filter((x) => x.id !== id));
    };

    return (
      <div
        title={`${content.event.title} ‚Ä¢ ${content.timeText}`}
        className={[
          "relative w-full h-full",
          "rounded-xl",
          "bg-white",
          "border border-neutral-200",
          "shadow-sm",
          "pl-3 pr-3 py-2",
          "text-neutral-900",
        ].join(" ")}
      >
        <div
          className={[
            "absolute left-0 top-1/2 -translate-y-1/2",
            "h-[calc(100%-10px)] w-1.5",
            "rounded-full",
            stripeBg,
          ].join(" ")}
        />

        {isLocal && (
          <button
            aria-label="Remove local"
            onClick={onRemoveLocal}
            className={[
              "absolute right-1 top-1",
              "h-5 w-5 flex items-center justify-center",
              "rounded-full border border-neutral-300 bg-white/90",
              "text-[11px] leading-none text-neutral-500",
              "hover:text-red-600 hover:border-red-300",
              "transition-colors",
            ].join(" ")}
          >
            √ó
          </button>
        )}

        {!isLocal && (
          <button
            aria-label="Delete"
            onClick={(e) => {
              e.stopPropagation();
              e.preventDefault();
              handleDeleteEvent(content.event.id as string);
            }}
            className={[
              "absolute right-1 top-1",
              "h-5 w-5 flex items-center justify-center",
              "rounded-full border border-neutral-300 bg-white/90",
              "text-[11px] leading-none text-neutral-500",
              "hover:text-red-600 hover:border-red-300",
              "transition-colors",
            ].join(" ")}
          >
            √ó
          </button>
        )}

        <div className="text-[11px] leading-none text-neutral-600">
          {content.timeText}
        </div>
        <div className="mt-1 line-clamp-1 text-xs font-semibold">
          {content.event.title}
        </div>
      </div>
    );
  };

  // --- local create/edit handlers ---
  const handleSelect = (sel: DateSelectArg) => {
    if (isDraggingPlaylist()) {
      sel.view.calendar.unselect();
      return;
    }
    const start = sel.start;
    const end = sel.end ?? new Date(start.getTime() + 30 * 60000);
    if (end.getTime() - start.getTime() < 5 * 60 * 1000) {
      sel.view.calendar.unselect();
      return;
    }
    const block: LocalEvt = {
      id: newId(),
      title: "New Block",
      start,
      end,
      allDay: false,
      extendedProps: { borderClass: DEFAULT_BORDER, isLocal: true },
    };
    setEvts((prev) => colorize([...prev, block]));
    sel.view.calendar.unselect();
  };

  const handleDateClick = (arg: DateClickArg) => {
    if (isDraggingPlaylist()) return;
    const start = arg.date;
    const end = new Date(start.getTime() + 30 * 60000);
    const block: LocalEvt = {
      id: newId(),
      title: "New Block",
      start,
      end,
      allDay: false,
      extendedProps: { borderClass: DEFAULT_BORDER, isLocal: true },
    };
    setEvts((prev) => colorize([...prev, block]));
    onDateClick?.(arg);
  };

  const handleEventDrop = (arg: EventDropArg) => {
    const id = arg.event.id;
    const start = arg.event.start!;
    const end = arg.event.end ?? new Date(start.getTime() + 30 * 60000);
    setEvts((prev) =>
      colorize(prev.map((e) => (e.id === id ? { ...e, start, end } : e)))
    );
  };

  useEffect(() => {
    const handler = (e: Event) => {
      const detail = (e as CustomEvent<{ localId?: string }>).detail;
      if (!detail?.localId) return;
      setEvts((prev) => prev.filter((x) => x.id !== detail.localId));
    };
    window.addEventListener(
      "schedule/local-committed",
      handler as EventListener
    );
    return () => {
      window.removeEventListener(
        "schedule/local-committed",
        handler as EventListener
      );
    };
  }, []);

  const handleEventResize = (arg: EventResizeDoneArg) => {
    const id = arg.event.id;
    const start = arg.event.start!;
    const end = arg.event.end!;
    setEvts((prev) =>
      colorize(prev.map((e) => (e.id === id ? { ...e, start, end } : e)))
    );
  };

  function selectedFromBackend(b: ScheduleBlock): Block {
    return {
      id: b.id,
      playlistId: b.playlistId,
      playlistName: b.playlistName,
      start_day: String(b.start_day ?? ""),
      start_time: String(b.start_time ?? ""),
      end_day: b.end_day ? String(b.end_day) : undefined,
      end_time: b.end_time ? String(b.end_time) : undefined,
      screens: (b.screens ?? [])
        .map((s: any) => toNum(s?.id))
        .filter((n: number | undefined): n is number => n != null)
        .map((n: number) => ({ screenId: n })),
      groups: (b.groups ?? [])
        .map((g: any) => toNum(g?.id))
        .filter((n: number | undefined): n is number => n != null)
        .map((n: number) => ({ groupId: n })),
      created_at: b.created_at,
      updated_at: b.updated_at,
    };
  }

  function selectedFromLocal(
    evt: { id: string; title: string; start: Date; end?: Date },
    extras?: {
      playlistId?: string | number;
      isInteractive?: boolean;
      durationSec?: number;
    }
  ): Block {
    const start = evt.start;
    const end = evt.end ?? new Date(start.getTime() + 30 * 60 * 1000);

    return {
      id: evt.id,
      playlistName: evt.title || "New Block",
      playlistId:
        extras?.playlistId != null ? Number(extras.playlistId) : undefined,
      start_day: fmtDay(start),
      start_time: fmtTime(start),
      end_day: fmtDay(end),
      end_time: fmtTime(end),
      screens: [] as { screenId: number }[],
      groups: [] as { groupId: number }[],
    };
  }

  const handleDatesSet = (arg: DatesSetArg) => {
  const { start, end, view } = arg;

  let prefix: "d" | "w" | "m";
  if (view.type.includes("Day")) prefix = "d";
  else if (view.type.includes("Week")) prefix = "w";
  else prefix = "m";

  // üëá ÿßŸÑÿ™ÿßÿ±ŸäÿÆ ŸÅŸÇÿ∑
  const startDate = start.toISOString().slice(0, 10); // "2025-11-29"
  const endDate = end.toISOString().slice(0, 10);     // "2025-12-06"

  // viewKey ŸÖÿ´ŸÑ ŸÇÿ®ŸÑ
  const viewKey = `${prefix}:${startDate}`;

  dispatch(
    setCalendarView({
      start: startDate,   // üëà ŸÖŸà ISO ŸÉÿßŸÖŸÑÿå ÿ®ÿ≥ YYYY-MM-DD
      end: endDate,       // üëà ŸÜŸÅÿ≥ ÿßŸÑÿ¥Ÿä
      viewType: view.type,
      viewKey,
    })
  );
};


  return (
    <>
      <div className="w-full">
        <div className="rounded-2xl border border-neutral-200 bg-white shadow-sm">
          {/* Top bar */}
          <div className="flex flex-wrap items-center justify-between gap-3 border-b border-neutral-200 px-4 py-3">
            <div className="flex items-center gap-2">
              <div className="h-2 w-2 rounded-full bg-emerald-500" />
              <h2 className="text-lg font-semibold text-neutral-800">
                Calendar
              </h2>
            </div>

            <div className="flex items-center gap-2">
              <button
                onClick={() => calendarRef.current?.getApi().today()}
                className="rounded-xl border border-neutral-300 px-3 py-1.5 text-sm font-medium text-neutral-700 hover:bg-neutral-50"
              >
                Today
              </button>
              <button
                onClick={() => calendarRef.current?.getApi().prev()}
                className="rounded-xl border border-neutral-300 px-3 py-1.5 text-sm font-medium text-neutral-700 hover:bg-neutral-50"
              >
                ‚Üê
              </button>
              <button
                onClick={() => calendarRef.current?.getApi().next()}
                className="rounded-xl border border-neutral-300 px-3 py-1.5 text-sm font-medium text-neutral-700 hover:bg-neutral-50"
              >
                ‚Üí
              </button>

              <div className="mx-1 hidden h-6 w-px bg-neutral-200 md:block" />

              <button
                onClick={() =>
                  calendarRef.current?.getApi().changeView("timeGridWeek")
                }
                className="rounded-xl border border-neutral-300 px-3 py-1.5 text-sm font-medium text-neutral-700 hover:bg-neutral-50"
              >
                Week
              </button>
              <button
                onClick={() =>
                  calendarRef.current?.getApi().changeView("timeGridDay")
                }
                className="rounded-xl border border-neutral-300 px-3 py-1.5 text-sm font-medium text-neutral-700 hover:bg-neutral-50"
              >
                Day
              </button>
              <button
                onClick={() =>
                  calendarRef.current?.getApi().changeView("dayGridMonth")
                }
                className="rounded-2xl border border-neutral-300 px-3 py-1.5 text-sm font-medium text-neutral-700 hover:bg-neutral-50"
              >
                Month
              </button>

              {/* Step input */}
              <div className="ml-2 flex items-center gap-2 rounded-xl border border-neutral-300 px-3 py-1.5 text-sm text-neutral-700">
                <span className="text-neutral-600">Step (min)</span>
                <input
                  type="number"
                  inputMode="numeric"
                  min={1}
                  max={360}
                  step={1}
                  value={slotStepMin}
                  onChange={(e) => {
                    const v = Number(e.target.value);
                    setSlotStepMin(Number.isFinite(v) ? v : 30);
                  }}
                  onBlur={(e) => {
                    const v = Math.max(
                      1,
                      Math.min(360, Math.floor(Number(e.target.value) || 30))
                    );
                    if (v !== slotStepMin) setSlotStepMin(v);
                  }}
                  className="w-20 rounded-md border border-neutral-300 px-2 py-1 text-sm text-neutral-800 focus:outline-none focus:ring-2 focus:ring-emerald-500/40"
                />
              </div>
            </div>
          </div>

          {/* Calendar */}
          <div className="p-2 md:p-4 fat-slots">
            {blocksLoading && (
              <div className="px-2 pb-2 text-xs text-neutral-500">
                Loading blocks for this range...
              </div>
            )}

            <FullCalendar
              ref={calendarRef as any}
              plugins={[dayGridPlugin, timeGridPlugin, interactionPlugin]}
              initialView={initialView}
              headerToolbar={false}
              datesSet={handleDatesSet}
              expandRows={false}
              dayMaxEvents={false}
              slotDuration={minutesToDur(slotStepMin)}
              snapDuration={minutesToDur(slotStepMin)}
              slotLabelInterval={slotStepMin < 30 ? { minutes: 60 } : undefined}
              nowIndicator
              selectable
              selectMirror
              selectOverlap
              unselectAuto
              selectLongPressDelay={50}
              defaultTimedEventDuration="00:30:00"
              selectMinDistance={8}
              editable
              eventOverlap={false}
              eventDisplay="block"
              events={finalEvents}
              scrollTime="00:00:00"
              scrollTimeReset={false}
              allDaySlot={false}
              droppable={true}
              eventReceive={(arg) => {
                const start = arg.event.start ?? new Date();
                const end =
                  arg.event.end ??
                  new Date(start.getTime() + slotStepMin * 60000);

                const ext = (arg.event.extendedProps || {}) as any;

                const localEvt: LocalEvt = {
                  id: newId(),
                  title: arg.event.title || "New Block",
                  start,
                  end,
                  allDay: false,
                  extendedProps: {
                    ...ext,
                    borderClass: DEFAULT_BORDER,
                    isLocal: true,
                  },
                };

                setEvts((prev) => colorize([...prev, localEvt]));

                setAssignOpen(true);
                dispatch(
                  setSelectedBlock(
                    selectedFromLocal(
                      { id: localEvt.id, title: localEvt.title, start, end },
                      {
                        playlistId: ext?.playlistId,
                        isInteractive: ext?.isInteractive,
                        durationSec: ext?.durationSec,
                      }
                    )
                  )
                );

                arg.event.remove();
                window.__draggingPlaylist = false;
              }}
              selectAllow={() => !isDraggingPlaylist()}
              dateClick={handleDateClick}
              eventClick={(arg) => {
                setAssignOpen(true);

                const id = arg.event.id;

                if (id.startsWith("block-")) {
                  const numericId = Number(id.replace("block-", ""));
                  const raw = ScheduleItemblocks.find((b: ScheduleBlock) => {
                    const bid =
                      typeof b?.id === "number" ? b.id : Number(b?.id);
                    return Number.isFinite(bid) && bid === numericId;
                  });
                  if (raw) dispatch(setSelectedBlock(selectedFromBackend(raw)));
                } else {
                  const start = arg.event.start ?? new Date();
                  const end =
                    arg.event.end ?? new Date(start.getTime() + 30 * 60000);
                  const ext = (arg.event.extendedProps || {}) as any;

                  dispatch(
                    setSelectedBlock(
                      selectedFromLocal(
                        { id, title: arg.event.title, start, end },
                        {
                          playlistId: ext?.playlistId,
                          isInteractive: ext?.isInteractive,
                          durationSec: ext?.durationSec,
                        }
                      )
                    )
                  );
                }

                onEventClick?.(arg);
              }}
              select={handleSelect}
              eventDrop={handleEventDrop}
              eventResize={handleEventResize}
              eventContent={renderEvent}
              stickyHeaderDates
              windowResizeDelay={50}
              slotMinTime="00:00:00"
              slotMaxTime="24:00:00"
              eventTimeFormat={{
                hour: "2-digit",
                minute: "2-digit",
                hour12: false,
              }}
              slotLabelFormat={{
                hour: "2-digit",
                minute: "2-digit",
                hour12: false,
              }}
              eventBackgroundColor="transparent"
              eventBorderColor="transparent"
              eventTextColor="inherit"
              eventClassNames={() => ["overflow-visible", "px-0", "py-0"]}
            />
          </div>
        </div>
      </div>

      {/* --- assign drawer --- */}
      {assignOpen && (
        <>
          <div
            className="fixed inset-0 z-40 bg-black/30 backdrop-blur-[1px]"
            onClick={() => {
              setAssignOpen(false);
              dispatch(clearSelectedBlock());
            }}
          />
          <aside
            className="fixed right-0 top-0 z-50 h-full w-[360px] border-l border-gray-200 bg-white shadow-xl"
            role="dialog"
            aria-label="Assign playlist"
          >
            <div className="flex items-center justify-between border-b border-gray-200 px-4 py-3">
              <div className="text-sm font-semibold text-gray-900">
                Assign playlist
              </div>
              <button
                onClick={() => {
                  setAssignOpen(false);
                  dispatch(clearSelectedBlock());
                }}
                className="rounded-md border border-gray-200 px-2 py-1.5 text-[12px] font-medium text-gray-700 hover:bg-gray-50"
              >
                Close
              </button>
            </div>
            <div className="h-[calc(100%-48px)] overflow-y-auto p-3 scrollbar-hide">
              <AssignSchedulebar
                onCancel={() => {
                  setAssignOpen(false);
                  dispatch(clearSelectedBlock());
                }}
              />
            </div>
          </aside>
        </>
      )}
    </>
  );
};

export default CalenderForScheduleItem;












// CalenderForScheduleItem.tsx
import React, { useEffect, useMemo, useRef, useState } from "react";
import FullCalendar from "@fullcalendar/react";
import dayGridPlugin from "@fullcalendar/daygrid";
import timeGridPlugin from "@fullcalendar/timegrid";
import interactionPlugin, {
  type DateClickArg,
  type EventResizeDoneArg,
} from "@fullcalendar/interaction";
import AssignSchedulebar from "../AssignSchedulebar";
import type {
  DateSelectArg,
  EventClickArg,
  EventContentArg,
  EventDropArg,
} from "@fullcalendar/core";
import { useDispatch, useSelector } from "react-redux";
import type { RootState } from "../../../../store";
import {
  setSelectedBlock,
  clearSelectedBlock,
  type Block,
} from "../../../Redux/Block/BlockSlice";
import type { DatesSetArg } from "@fullcalendar/core";
// NEW üëá
import { removeScheduleItemBlock } from "../../../Redux/ScheduleItem/ScheduleItemSlice";
import { useDeleteReservedBlock } from "../../../Redux/Block/DeleteBlock";
import { setCalendarView } from "@/Redux/Calendar/calendarViewSlice";
import { setBlocksForView, setCurrentBlocksFromCache, setScheduleBlocksLoading } from "@/Redux/ScheduleItem/scheduleBlocksSlice";
import { useScheduleItemBlocksByView } from "@/Redux/ScheduleItem/useScheduleItemBlocksByView";

declare global {
  interface Window {
    __draggingPlaylist?: boolean;
  }
}
const isDraggingPlaylist = () => Boolean(window.__draggingPlaylist);

/* -------------------------------- types ---------------------------------- */
type CalenderProps = {
  initialView?: "timeGridWeek" | "timeGridDay" | "dayGridMonth";
  events?: Array<{
    id?: string;
    title: string;
    start: string | Date;
    end?: string | Date;
    allDay?: boolean;
    extendedProps?: { borderClass?: string };
  }>;
  onDateClick?: (arg: DateClickArg) => void;
  onEventClick?: (arg: EventClickArg) => void;
};

type LocalEvt = {
  id: string;
  title: string;
  start: Date | string;
  end?: Date | string;
  allDay?: boolean;
  extendedProps?: { borderClass?: string; isLocal?: boolean; [k: string]: any };
};

/* -------------------------------- helpers -------------------------------- */
const DEFAULT_BORDER = "border-red-600";

const minutesToDur = (m: number) => {
  const mins = Math.max(1, Math.min(360, Math.floor(m || 0)));
  const h = Math.floor(mins / 60);
  const mm = mins % 60;
  const pad = (n: number) => (n < 10 ? `0${n}` : `${n}`);
  return `${pad(h)}:${pad(mm)}:00`;
};

const toTs = (v?: Date | string | null) =>
  !v ? Number.NaN : typeof v === "string" ? new Date(v).getTime() : v.getTime();

const toNum = (v: any): number | undefined => {
  const n = typeof v === "number" ? v : Number(v);
  return Number.isFinite(n) ? n : undefined;
};

function colorize(input: LocalEvt[]): LocalEvt[] {
  const arr = [...input].sort((a, b) => {
    const as = toTs(a.start),
      bs = toTs(b.start);
    if (as !== bs) return as - bs;
    return (toTs(a.end) || as) - (toTs(b.end) || bs);
  });
  return arr.map((e) => ({
    ...e,
    extendedProps: {
      ...(e.extendedProps ?? {}),
      borderClass: e.extendedProps?.borderClass ?? DEFAULT_BORDER,
      isLocal: e.extendedProps?.isLocal ?? false,
    },
  }));
}

const toBg = (cls?: string) =>
  cls && cls.startsWith("border-")
    ? cls.replace("border-", "bg-")
    : cls ?? "bg-red-600";

let uid = 1;
const newId = () => `e${uid++}`;

const pad = (n: number) => (n < 10 ? `0${n}` : `${n}`);
const fmtDay = (d: Date) =>
  `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())}`;
const fmtTime = (d: Date) =>
  `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;

/* -------------------------------- component ------------------------------- */
const CalenderForScheduleItem: React.FC<CalenderProps> = ({
  initialView = "timeGridWeek",
  events,
  onDateClick,
  onEventClick,
}) => {
  const calendarRef = useRef<FullCalendar | null>(null);
  const [assignOpen, setAssignOpen] = useState(false);
  const [slotStepMin, setSlotStepMin] = useState<number>(30);
  const dispatch = useDispatch();

  const ScheduleItemblocks = useSelector(
    (s: RootState) => s.ScheduleItem.scheduleItemBlocks
  );
  const selectedScreenStr = useSelector(
    (s: RootState) => s.ScheduleItem.selectedscreenId
  );
  const selectedGroupStr = useSelector(
    (s: RootState) => s.ScheduleItem.selectedgroupId
  );

  const selectedScreenId =
    selectedScreenStr != null ? Number(selectedScreenStr) : null;
  const selectedGroupId =
    selectedGroupStr != null ? Number(selectedGroupStr) : null;

  const { start, end, viewKey } = useSelector((s: RootState) => s.calendarView);
  console.log("start at", start, "end at ", end, "KEY", viewKey);

const { scheduleItemId, cache } = useSelector(
  (s: RootState) => s.scheduleBlocks
);

useEffect(() => {
  if (!scheduleItemId || !start || !end || !viewKey) return;

  const cached = cache[viewKey];
  if (cached) {
    // cache hit ‚Üí just use it
    dispatch(setCurrentBlocksFromCache({ viewKey }));
    return;
  }

  // cache miss ‚Üí DB request
  dispatch(setScheduleBlocksLoading(true));

  (async () => {
    try {
      const blocksFromDB: Block[] = await apiGetBlocksForScheduleAndRange({
        scheduleItemId,
        start,
        end,
      });

      dispatch(setBlocksForView({ viewKey, blocks: blocksFromDB }));
    } catch (err) {
      console.error(err);
      dispatch(setScheduleBlocksLoading(false));
    }
  })();
}, [scheduleItemId, start, end, viewKey]);



  const [evts, setEvts] = useState<LocalEvt[]>(
    colorize((events ?? []).map((e, i) => ({ ...e, id: e.id ?? `seed-${i}` })))
  );

  function toDateTime(day?: string, time?: string): Date | undefined {
    if (!day || !time) return undefined;
    const d = new Date(`${day}T${time}`);
    return isNaN(d.getTime()) ? undefined : d;
  }

  const backendEvents: LocalEvt[] = useMemo(() => {
    if (!Array.isArray(ScheduleItemblocks)) return [];
    return ScheduleItemblocks.map((b) => {
      const start =
        toDateTime(b.start_day as any, b.start_time as any) ?? new Date();
      const fallbackEnd = new Date(start.getTime() + 30 * 60 * 1000);
      const end =
        toDateTime(b.end_day as any, b.end_time as any) ?? fallbackEnd;

      const title = (b as any).playlistName
        ? String((b as any).playlistName)
        : `Block #${b.id}`;

      return {
        id: `block-${b.id}`,
        title,
        start,
        end,
        allDay: false,
        extendedProps: { borderClass: DEFAULT_BORDER, isLocal: false },
      };
    });
  }, [ScheduleItemblocks]);

  const filteredBackendEvents: LocalEvt[] = useMemo(() => {
    if (selectedScreenId == null && selectedGroupId == null)
      return backendEvents;

    const matches = (b: any) => {
      const hasScreen =
        selectedScreenId == null
          ? true
          : (b.screens ?? []).some((s: any) => {
              const id = typeof s?.id === "number" ? s.id : Number(s?.id);
              return Number.isFinite(id) && id === selectedScreenId;
            });

      const hasGroup =
        selectedGroupId == null
          ? true
          : (b.groups ?? []).some((g: any) => {
              const id = typeof g?.id === "number" ? g.id : Number(g?.id);
              return Number.isFinite(id) && id === selectedGroupId;
            });

      return hasScreen && hasGroup;
    };

    const selectedBlocks = (ScheduleItemblocks ?? []).filter(matches);

    return selectedBlocks.map((b) => {
      const start =
        toDateTime(b.start_day as any, b.start_time as any) ?? new Date();
      const fallbackEnd = new Date(start.getTime() + 30 * 60 * 1000);
      const end =
        toDateTime(b.end_day as any, b.end_time as any) ?? fallbackEnd;

      const title = (b as any).playlistName
        ? String((b as any).playlistName)
        : `Block #${b.id}`;

      return {
        id: `block-${b.id}`,
        title,
        start,
        end,
        allDay: false,
        extendedProps: { borderClass: DEFAULT_BORDER, isLocal: false },
      };
    });
  }, [ScheduleItemblocks, backendEvents, selectedScreenId, selectedGroupId]);

  const finalEvents = useMemo(
    () => colorize([...(filteredBackendEvents ?? []), ...(evts ?? [])]),
    [filteredBackendEvents, evts]
  );

  // NEW üëá delete hook and helpers
  const { mutateAsync: deleteBlock } = useDeleteReservedBlock();

  const toServerId = (eventId: string): number | null => {
    if (!eventId) return null;
    if (eventId.startsWith("block-")) {
      const n = Number(eventId.replace("block-", ""));
      return Number.isFinite(n) ? n : null;
    }
    const n = Number(eventId);
    return Number.isFinite(n) ? n : null;
  };

  const handleDeleteEvent = async (eventId: string) => {
    const idNum = toServerId(eventId);
    if (!idNum) return;
    if (!window.confirm("Delete this block?")) return;
    try {
      await deleteBlock(idNum); // ‚Üê DB delete
      // Redux + local cleanup
      dispatch(removeScheduleItemBlock(idNum));
      setEvts((prev) =>
        prev.filter((x) => x.id !== String(idNum) && x.id !== `block-${idNum}`)
      );
      window.dispatchEvent(
        new CustomEvent("schedule/removed", { detail: { id: String(idNum) } })
      );
    } catch (err) {
      console.error("[CalenderForScheduleItem delete] error:", err);
    }
  };

  // Listen for external removals (keep local evts in sync)
  useEffect(() => {
    const onRemoved = (e: Event) => {
      const { id } = (e as CustomEvent<{ id?: string }>).detail ?? {};
      if (!id) return;
      setEvts((prev) =>
        prev.filter((x) => x.id !== id && x.id !== `block-${id}`)
      );
    };
    window.addEventListener("schedule/removed", onRemoved as EventListener);
    return () => {
      window.removeEventListener(
        "schedule/removed",
        onRemoved as EventListener
      );
    };
  }, []);

  const renderEvent = (content: EventContentArg) => {
    const { borderClass, isLocal } =
      (content.event.extendedProps as {
        borderClass?: string;
        isLocal?: boolean;
      }) || {};
    const stripeBg = toBg(borderClass || DEFAULT_BORDER);

    const onRemoveLocal = (e: React.MouseEvent) => {
      e.stopPropagation();
      e.preventDefault();
      const id = content.event.id;
      setEvts((prev) => prev.filter((x) => x.id !== id));
    };

    return (
      <div
        title={`${content.event.title} ‚Ä¢ ${content.timeText}`}
        className={[
          "relative w-full h-full",
          "rounded-xl",
          "bg-white",
          "border border-neutral-200",
          "shadow-sm",
          "pl-3 pr-3 py-2",
          "text-neutral-900",
        ].join(" ")}
      >
        <div
          className={[
            "absolute left-0 top-1/2 -translate-y-1/2",
            "h-[calc(100%-10px)] w-1.5",
            "rounded-full",
            stripeBg,
          ].join(" ")}
        />

        {/* Local drafts: show √ó to remove locally */}
        {isLocal && (
          <button
            aria-label="Remove local"
            onClick={onRemoveLocal}
            className={[
              "absolute right-1 top-1",
              "h-5 w-5 flex items-center justify-center",
              "rounded-full border border-neutral-300 bg-white/90",
              "text-[11px] leading-none text-neutral-500",
              "hover:text-red-600 hover:border-red-300",
              "transition-colors",
            ].join(" ")}
          >
            √ó
          </button>
        )}

        {/* Persisted events: show √ó to delete from DB */}
        {!isLocal && (
          <button
            aria-label="Delete"
            onClick={(e) => {
              e.stopPropagation();
              e.preventDefault();
              handleDeleteEvent(content.event.id as string);
            }}
            className={[
              "absolute right-1 top-1",
              "h-5 w-5 flex items-center justify-center",
              "rounded-full border border-neutral-300 bg-white/90",
              "text-[11px] leading-none text-neutral-500",
              "hover:text-red-600 hover:border-red-300",
              "transition-colors",
            ].join(" ")}
          >
            √ó
          </button>
        )}

        <div className="text-[11px] leading-none text-neutral-600">
          {content.timeText}
        </div>
        <div className="mt-1 line-clamp-1 text-xs font-semibold">
          {content.event.title}
        </div>
      </div>
    );
  };

  // --- local create/edit handlers ---
  const handleSelect = (sel: DateSelectArg) => {
    if (isDraggingPlaylist()) {
      sel.view.calendar.unselect();
      return;
    }
    const start = sel.start;
    const end = sel.end ?? new Date(start.getTime() + 30 * 60000);
    if (end.getTime() - start.getTime() < 5 * 60 * 1000) {
      sel.view.calendar.unselect();
      return;
    }
    const block: LocalEvt = {
      id: newId(),
      title: "New Block",
      start,
      end,
      allDay: false,
      extendedProps: { borderClass: DEFAULT_BORDER, isLocal: true },
    };
    setEvts((prev) => colorize([...prev, block]));
    sel.view.calendar.unselect();
  };

  const handleDateClick = (arg: DateClickArg) => {
    if (isDraggingPlaylist()) return;
    const start = arg.date;
    const end = new Date(start.getTime() + 30 * 60000);
    const block: LocalEvt = {
      id: newId(),
      title: "New Block",
      start,
      end,
      allDay: false,
      extendedProps: { borderClass: DEFAULT_BORDER, isLocal: true },
    };
    setEvts((prev) => colorize([...prev, block]));
    onDateClick?.(arg);
  };

  const handleEventDrop = (arg: EventDropArg) => {
    const id = arg.event.id;
    const start = arg.event.start!;
    const end = arg.event.end ?? new Date(start.getTime() + 30 * 60000);
    setEvts((prev) =>
      colorize(prev.map((e) => (e.id === id ? { ...e, start, end } : e)))
    );
  };

  useEffect(() => {
    const handler = (e: Event) => {
      const detail = (e as CustomEvent<{ localId?: string }>).detail;
      if (!detail?.localId) return;
      setEvts((prev) => prev.filter((x) => x.id !== detail.localId));
    };
    window.addEventListener(
      "schedule/local-committed",
      handler as EventListener
    );
    return () => {
      window.removeEventListener(
        "schedule/local-committed",
        handler as EventListener
      );
    };
  }, []);

  const handleEventResize = (arg: EventResizeDoneArg) => {
    const id = arg.event.id;
    const start = arg.event.start!;
    const end = arg.event.end!;
    setEvts((prev) =>
      colorize(prev.map((e) => (e.id === id ? { ...e, start, end } : e)))
    );
  };

  function selectedFromBackend(b: any): Block {
    return {
      id: b.id,
      playlistId: b.playlistId ?? b.playlist_id,
      playlistName: b.playlistName ?? b.playlist_name,
      start_day: String(b.start_day ?? ""),
      start_time: String(b.start_time ?? ""),
      end_day: b.end_day ? String(b.end_day) : undefined,
      end_time: b.end_time ? String(b.end_time) : undefined,
      screens: (b.screens ?? [])
        .map((s: any) => toNum(s?.id))
        .filter((n: number | undefined): n is number => n != null)
        .map((n: number) => ({ screenId: n })),
      groups: (b.groups ?? [])
        .map((g: any) => toNum(g?.id))
        .filter((n: number | undefined): n is number => n != null)
        .map((n: number) => ({ groupId: n })),
      created_at: b.created_at,
      updated_at: b.updated_at,
    };
  }

  function selectedFromLocal(
    evt: { id: string; title: string; start: Date; end?: Date },
    extras?: {
      playlistId?: string | number;
      isInteractive?: boolean;
      durationSec?: number;
    }
  ): Block {
    const start = evt.start;
    const end = evt.end ?? new Date(start.getTime() + 30 * 60 * 1000);

    return {
      id: evt.id,
      playlistName: evt.title || "New Block",
      playlistId:
        extras?.playlistId != null ? Number(extras.playlistId) : undefined,
      start_day: fmtDay(start),
      start_time: fmtTime(start),
      end_day: fmtDay(end),
      end_time: fmtTime(end),
      screens: [] as { screenId: number }[],
      groups: [] as { groupId: number }[],
    };
  }
  const handleDatesSet = (arg: DatesSetArg) => {
    const { start, end, view } = arg;

    // 1) detect prefix from view.type
    //    FullCalendar will give types like "timeGridWeek", "timeGridDay", "dayGridMonth"
    let prefix: "d" | "w" | "m";
    if (view.type.includes("Day")) prefix = "d";
    else if (view.type.includes("Week")) prefix = "w";
    else prefix = "m"; // default to month for other views like dayGridMonth

    // 2) build start ISO date (YYYY-MM-DD)
    const startISO = start.toISOString().slice(0, 10); // e.g. "2025-11-17"
    const endISO = end.toISOString(); // full ISO is fine

    // 3) build viewKey like "w:2025-11-17"
    const viewKey = `${prefix}:${startISO}`;

    // 4) push to redux
    dispatch(
      setCalendarView({
        start: start.toISOString(),
        end: endISO,
        viewType: view.type,
        viewKey,
      })
    );
  };

  return (
    <>
      <div className="w-full">
        <div className="rounded-2xl border border-neutral-200 bg-white shadow-sm">
          {/* Top bar */}
          <div className="flex flex-wrap items-center justify-between gap-3 border-b border-neutral-200 px-4 py-3">
            <div className="flex items-center gap-2">
              <div className="h-2 w-2 rounded-full bg-emerald-500" />
              <h2 className="text-lg font-semibold text-neutral-800">
                Calendar
              </h2>
            </div>

            <div className="flex items-center gap-2">
              <button
                onClick={() => calendarRef.current?.getApi().today()}
                className="rounded-xl border border-neutral-300 px-3 py-1.5 text-sm font-medium text-neutral-700 hover:bg-neutral-50"
              >
                Today
              </button>
              <button
                onClick={() => calendarRef.current?.getApi().prev()}
                className="rounded-xl border border-neutral-300 px-3 py-1.5 text-sm font-medium text-neutral-700 hover:bg-neutral-50"
              >
                ‚Üê
              </button>
              <button
                onClick={() => calendarRef.current?.getApi().next()}
                className="rounded-xl border border-neutral-300 px-3 py-1.5 text-sm font-medium text-neutral-700 hover:bg-neutral-50"
              >
                ‚Üí
              </button>

              <div className="mx-1 hidden h-6 w-px bg-neutral-200 md:block" />

              <button
                onClick={() =>
                  calendarRef.current?.getApi().changeView("timeGridWeek")
                }
                className="rounded-xl border border-neutral-300 px-3 py-1.5 text-sm font-medium text-neutral-700 hover:bg-neutral-50"
              >
                Week
              </button>
              <button
                onClick={() =>
                  calendarRef.current?.getApi().changeView("timeGridDay")
                }
                className="rounded-xl border border-neutral-300 px-3 py-1.5 text-sm font-medium text-neutral-700 hover:bg-neutral-50"
              >
                Day
              </button>
              <button
                onClick={() =>
                  calendarRef.current?.getApi().changeView("dayGridMonth")
                }
                className="rounded-2xl border border-neutral-300 px-3 py-1.5 text-sm font-medium text-neutral-700 hover:bg-neutral-50"
              >
                Month
              </button>

              {/* Step input */}
              <div className="ml-2 flex items-center gap-2 rounded-xl border border-neutral-300 px-3 py-1.5 text-sm text-neutral-700">
                <span className="text-neutral-600">Step (min)</span>
                <input
                  type="number"
                  inputMode="numeric"
                  min={1}
                  max={360}
                  step={1}
                  value={slotStepMin}
                  onChange={(e) => {
                    const v = Number(e.target.value);
                    setSlotStepMin(Number.isFinite(v) ? v : 30);
                  }}
                  onBlur={(e) => {
                    const v = Math.max(
                      1,
                      Math.min(360, Math.floor(Number(e.target.value) || 30))
                    );
                    if (v !== slotStepMin) setSlotStepMin(v);
                  }}
                  className="w-20 rounded-md border border-neutral-300 px-2 py-1 text-sm text-neutral-800 focus:outline-none focus:ring-2 focus:ring-emerald-500/40"
                />
              </div>
            </div>
          </div>

          {/* Calendar */}
          <div className="p-2 md:p-4 fat-slots">
            <FullCalendar
              ref={calendarRef as any}
              plugins={[dayGridPlugin, timeGridPlugin, interactionPlugin]}
              initialView={initialView}
              headerToolbar={false}
              datesSet={handleDatesSet}
              expandRows={false}
              dayMaxEvents={false}
              slotDuration={minutesToDur(slotStepMin)}
              snapDuration={minutesToDur(slotStepMin)}
              slotLabelInterval={slotStepMin < 30 ? { minutes: 60 } : undefined}
              nowIndicator
              selectable
              selectMirror
              selectOverlap
              unselectAuto
              selectLongPressDelay={50}
              defaultTimedEventDuration="00:30:00"
              selectMinDistance={8}
              editable
              eventOverlap={false}
              eventDisplay="block"
              events={finalEvents}
              scrollTime="00:00:00"
              scrollTimeReset={false}
              allDaySlot={false}
              droppable={true}
              eventReceive={(arg) => {
                const start = arg.event.start ?? new Date();
                const end =
                  arg.event.end ??
                  new Date(start.getTime() + slotStepMin * 60000);

                const ext = (arg.event.extendedProps || {}) as any;

                const localEvt: LocalEvt = {
                  id: newId(),
                  title: arg.event.title || "New Block",
                  start,
                  end,
                  allDay: false,
                  extendedProps: {
                    ...ext, // keep playlistId, isInteractive, durationSec, etc.
                    borderClass: DEFAULT_BORDER,
                    isLocal: true,
                  },
                };

                setEvts((prev) => colorize([...prev, localEvt]));

                setAssignOpen(true);
                dispatch(
                  setSelectedBlock(
                    selectedFromLocal(
                      { id: localEvt.id, title: localEvt.title, start, end },
                      {
                        playlistId: ext?.playlistId,
                        isInteractive: ext?.isInteractive,
                        durationSec: ext?.durationSec,
                      }
                    )
                  )
                );

                arg.event.remove();
                window.__draggingPlaylist = false;
              }}
              // Prevent creation while dragging from list
              selectAllow={() => !isDraggingPlaylist()}
              dateClick={handleDateClick}
              eventClick={(arg) => {
                setAssignOpen(true);

                const id = arg.event.id;

                if (id.startsWith("block-")) {
                  // backend block
                  const numericId = Number(id.replace("block-", ""));
                  const raw = (ScheduleItemblocks ?? []).find((b: any) => {
                    const bid =
                      typeof b?.id === "number" ? b.id : Number(b?.id);
                    return Number.isFinite(bid) && bid === numericId;
                  });
                  if (raw) dispatch(setSelectedBlock(selectedFromBackend(raw)));
                } else {
                  // local event ‚Üí include extendedProps.playlistId
                  const start = arg.event.start ?? new Date();
                  const end =
                    arg.event.end ?? new Date(start.getTime() + 30 * 60000);
                  const ext = (arg.event.extendedProps || {}) as any;

                  dispatch(
                    setSelectedBlock(
                      selectedFromLocal(
                        { id, title: arg.event.title, start, end },
                        {
                          playlistId: ext?.playlistId,
                          isInteractive: ext?.isInteractive,
                          durationSec: ext?.durationSec,
                        }
                      )
                    )
                  );
                }

                onEventClick?.(arg);
              }}
              select={handleSelect}
              eventDrop={handleEventDrop}
              eventResize={handleEventResize}
              eventContent={renderEvent}
              stickyHeaderDates
              windowResizeDelay={50}
              slotMinTime="00:00:00"
              slotMaxTime="24:00:00"
              eventTimeFormat={{
                hour: "2-digit",
                minute: "2-digit",
                hour12: false,
              }}
              slotLabelFormat={{
                hour: "2-digit",
                minute: "2-digit",
                hour12: false,
              }}
              eventBackgroundColor="transparent"
              eventBorderColor="transparent"
              eventTextColor="inherit"
              eventClassNames={() => ["overflow-visible", "px-0", "py-0"]}
            />
          </div>
        </div>
      </div>

      {/* --- assign drawer (unchanged UI) --- */}
      {assignOpen && (
        <>
          <div
            className="fixed inset-0 z-40 bg-black/30 backdrop-blur-[1px]"
            onClick={() => {
              setAssignOpen(false);
              dispatch(clearSelectedBlock());
            }}
          />
          <aside
            className="fixed right-0 top-0 z-50 h-full w-[360px] border-l border-gray-200 bg-white shadow-xl"
            role="dialog"
            aria-label="Assign playlist"
          >
            <div className="flex items-center justify-between border-b border-gray-200 px-4 py-3">
              <div className="text-sm font-semibold text-gray-900">
                Assign playlist
              </div>
              <button
                onClick={() => {
                  setAssignOpen(false);
                  dispatch(clearSelectedBlock());
                }}
                className="rounded-md border border-gray-200 px-2 py-1.5 text-[12px] font-medium text-gray-700 hover:bg-gray-50"
              >
                Close
              </button>
            </div>
            <div className="h-[calc(100%-48px)] overflow-y-auto p-3 scrollbar-hide">
              <AssignSchedulebar
                onCancel={() => {
                  setAssignOpen(false);
                  dispatch(clearSelectedBlock());
                }}
              />
            </div>
          </aside>
        </>
      )}
    </>
  );
};

export default CalenderForScheduleItem;
